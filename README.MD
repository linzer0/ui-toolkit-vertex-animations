# Between the lines : Vertex animation in UI Toolkit


## Chapter 1: Animation concept

Хочу начать с объяснение того, как будет работать анимация у наших элеметов интерфейса.

Речь идет не про Transition/Delays/и других встроенных возможностях анимации в UI Toolkit'е.

Мы продолжим изучение возможностей генерации интерфейсов на основе создания вершин и меша.

Из предыдущих статей мы научилист создавать кастомные UI элементы, теперь давайте добавим немного динамичности.

Стоит сказать, что генерация анимации развлечение не самое дешевое с точки зрения производительности, так как она будет нагружать CPU чуть ли не каждый кадр.

Если разобрать анимацию на базовые составляющие, то это изменение состояния объекта (это может быть размеры, формы, цвет, положение).

Первая задача которая стоит перед нами, научиться вызывать внутренние методы класса **VisualElement'а**, через определенные количетсво времени. 

Для этого мы будем использовать внутренюю реализацию интерфейса **IVisualElementScheduler**.

Из названия можно догадаться, что оно занимается планирование и выполнение каких-то действий, давайте разбираться как с ним работать.
```csharp
public RombElement()
{
    schedule.execute(MethodName);
}
```

В этом примере кода, при создание элемента мы обращаемся к методу **Execute** передавая в него **Action**.

Это значит, что этот метод будет вызван сразу после выполнения конструктора.

Стоит понимать, что выполнен он будет только один раз, а как нам сделать многократные вызовы?

– Я рад, что вы спросили, отвечаю:

```csharp
public RombElement()
{
    schedule.Execute(MethodName).Every(16);
}
```

Мы добавляем к нашему вызову **.Every**, что означает, наш метод будет вызываться каждые X милисекунд.
